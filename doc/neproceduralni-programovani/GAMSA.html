<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="initial-scale = 1.0,maximum-scale = 1.0" />
    <title>neproc:gamsa</title>
    <link rel="stylesheet" type="text/css" media="all" href="../../styles.css" />
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
    <script src="https://unpkg.com/popper.js@1"></script>
    <script src="https://unpkg.com/tippy.js@5"></script>
    <script type="text/x-mathjax-config">
        MathJax.Ajax.config.path["mhchem"] = "https://cdnjs.cloudflare.com/ajax/libs/mathjax-mhchem/3.3.2";
        MathJax.Hub.Config({
            jax: ["input/TeX","output/CommonHTML"],
            extensions: ["[mhchem]/mhchem.js", "tex2jax.js","MathMenu.js","MathZoom.js", "AssistiveMML.js", "a11y/accessibility-menu.js"],
            TeX: {
                extensions: ["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]
            },
            CommonHTML: {
                scale: 98
            }
        });
    </script>
    <script type="text/javascript" async
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js">
        </script>
    <script type="text/javascript">
        var visibilities = {};
        function toggleImageVisible(id) {
            var img = document.getElementById(id);
            if (id in visibilities) {
                 img.style.display = (visibilities[id] ? 'none' : 'block');
                 visibilities[id] = !visibilities[id];
            } else {
                img.style.display = 'block'
                visibilities[id] = true;
            }
        }

        let h;
        document.onreadystatechange = function() {
            if (document.readyState == "interactive") {
                h = document.getElementById('sticky-header');
                tippy("abr", {
                    boundary: "window",
                    maxWidth: "none"
                });

                $("img").click(function() {
                    var src = $(this).attr('src');
                    $('<div>').css({
                        background: 'RGBA(0,0,0,.5) url('+src+') no-repeat center',
                        backgroundSize: 'contain',
                        width:'100%', height:'100%',
                        position:'fixed',
                        zIndex:'10000',
                        top:'0', left:'0',
                        cursor: 'zoom-out'
                    }).click(function(){
                        $(this).remove();
                    }).appendTo('body');
                });
            }
        }

        let lastOffset = 10;
        let first = true;
        window.onscroll = function() {
            var doc = document.documentElement;
            var o = (window.pageYOffset || doc.scrollTop)  - (doc.clientTop || 0);
            if (o <= 8 && (lastOffset > 8 || first)) {
                first = false;
                h.style.boxShadow = 'none';
                h.style.backgroundColor = 'rgb(255, 255, 255)';
            } else if (o > 8 && (lastOffset <= 8 || first)) {
                first = false;
                h.style.boxShadow = '0px 1px 3px lightgrey';
                h.style.backgroundColor = 'rgb(255, 255, 255)';
            }
            lastOffset = window.pageYOffset;
        };

        function showAllSlides() {
            allSlides = document.getElementsByClassName("slide");
            for (i = 0; i < allSlides.length; i++) {
                var id = allSlides[i].id;
                if (!visibilities[id]) {
                    toggleImageVisible(allSlides[i].id);
                }
            }
        }

        function hideAllSlides() {
            allSlides = document.getElementsByClassName("slide");
            for (i = 0; i < allSlides.length; i++) {
                var id = allSlides[i].id;
                if (visibilities[id]) {
                    toggleImageVisible(allSlides[i].id);
                }
            }
        }
    </script>
</head>

<body>
    <div class="sticky-header" id="sticky-header">
        <div class="wrapper">
            <span class="page-title"><a class="no-style" href="/bioinformatika" title="ÃšvodnÃ­ strÃ¡nka">notes</a>:<a class="no-style" href=lecture-page.html title="NeprocedurÃ¡lnÃ­ programovÃ¡nÃ­">neproc</a>:<strong>gamsa</strong></span>
            <span class="page-navigation">
                &lt;<a href="javascript:showAllSlides()">+</a>/<a href="javascript:hideAllSlides()">â€“</a>&gt;
            </span>
        </div>
    </div>
    <div class="container">
        <h1 id="Obsah"><a class="internal-link" href="#Obsah">Obsah</a></h1>

        <ol class="toc"><ol><li><strong><a class="internal-link" href="#GAMSA">GAMSA</a></strong>
        <ul><li><a class="internal-link" href="#Princip funkce">Princip funkce</a>
        <ul><li><a class="internal-link" href="#Sequence alignment">Sequence alignment</a></li><li><a class="internal-link" href="#Tvorba generacÃ­">Tvorba generacÃ­</a></li><li><a class="internal-link" href="#RekombinaÄnÃ­ operace">RekombinaÄnÃ­ operace</a></li><li><a class="internal-link" href="#Fitness function">Fitness function</a></li></ul></li><li><a class="internal-link" href="#Orientace v kÃ³du">Orientace v kÃ³du</a></li><li><a class="internal-link" href="#OsobnÃ­ poznÃ¡mky">OsobnÃ­ poznÃ¡mky</a></li></ul></li></ol></ol>

<h1 id="GAMSA"><a class="internal-link" href="#GAMSA">GAMSA</a></h1><p>GAMSA (genetic algorithm multiple sequence alignment) je mÅ¯j program, ve kterÃ©m jsem seâ€”jak uÅ¾ nÃ¡zev napovÃ­dÃ¡â€”pokusil implementovat MSA pomocÃ­ genetickÃ©ho algoritmu. KÃ³d je dostupnÃ½ na <a href="https://github.com/Eugleo/gamsa">mÃ©m GitHubu</a>. Informace jsem Äerpal pÅ™edevÅ¡Ã­m z tÄ›chto dvou ÄlÃ¡nkÅ¯:</p><ul><li><a href="http://www.funpecrp.com.br/gmr/year2007/vol4-6/pdf/Xm0016.pdf">A simple genetic algorithm for multiple sequence alignment</a></li><li><a href="https://www.researchgate.net/publication/234831605_Multiple_Sequence_Alignment_Using_a_Genetic_Algorithm_and_GLOCSA">Multiple Sequence Alignment Using a Genetic Algorithm and GLOCSA</a></li></ul><h2 id="Princip funkce"><a class="internal-link" href="#Princip funkce">Princip funkce</a></h2><p>High-level popis funkce je velice podobnÃ½ jako u vÅ¡ech GA, tedy</p><ol><li>Ze seedu vygenerujeme poÄÃ¡teÄnÃ­ populaci (kaÅ¾dÃ© jednÃ© populaci pak Å™Ã­kÃ¡me <em>generace</em>).</li><li>Ze souÄasnÃ© generace vytvoÅ™Ã­me rÅ¯znÃ½mi rekombinaÄnÃ­mi zpÅ¯soby novou generaci o stejnÃ©m poÄtu jedincÅ¯. Tento bod mnohokrÃ¡t opakujeme.
<ul><li>ÄŒasto se hodÃ­ vÄ›dÄ›t, jak â€œdobrÃ½â€ je danÃ½ <em>jedinec</em>; k tomu slouÅ¾Ã­ takzvanÃ¡ <em>fitness function</em>. KdyÅ¾ budu v textu mluvit o â€œnejlepÅ¡Ã­m jedinciâ€, budu mÃ­t vÅ¾dy namysli jedince s nejvyÅ¡Å¡Ã­ hodnotou fitness function.</li></ul></li><li>Z poslednÃ­ generace vybereme nejlepÅ¡Ã­ho jedince, kterÃ½ je vÃ½stupem celÃ©ho programu.</li></ol><p>CelÃ½ proces si lze pÅ™edstavit jako prohledÃ¡vÃ¡nÃ­ grafu, kde vrcholy jsou rÅ¯znÃ­ jedinci a hrany mezi nimi jsou rÅ¯znÃ© rekombinaÄnÃ­ operace. Graf je ale tak velkÃ½, Å¾e bÄ›Å¾nÃ© zpÅ¯soby prohledÃ¡vÃ¡nÃ­ na nÄ›j nefungujÃ­, proto se pouÅ¾Ã­vajÃ­ genetickÃ© algoritmy.</p><h3 id="Sequence alignment"><a class="internal-link" href="#Sequence alignment">Sequence alignment</a></h3><p><em>Pro vÃ­ce informacÃ­ viz napÅ™Ã­klad sekce o sequence alignmentu <a href="https://eugleo.github.io/bioinformatika/doc/zaklady-bioinformatiky/notes.html#Pairwise%20sequence%20alignment">v mÃ½ch zÃ¡pisech</a>.</em></p><p>Multiple sequence alignment je bioinformatickÃ¡ metoda, kterÃ¡ se snaÅ¾Ã­ v nÄ›kolika sekvencÃ­ch (vÄ›tÅ¡inou proteinech) najÃ­t prvky (vÄ›tÅ¡inou aminokyseliny), kterÃ© pochÃ¡zejÃ­ ze stejnÃ©ho pÅ™edka.</p><p>V praxi to znamenÃ¡, Å¾e mÃ¡me <mathjax>\(n\)</mathjax> sekvencÃ­ znakÅ¯, kterÃ© se snaÅ¾Ã­me nÄ›jak srovnat pod sebe. Sekvence pod sebe srovnÃ¡vÃ¡me tak, Å¾e do nich doplÅˆujeme mezery; vÃ½sledÃ©mu souboru pÅ¯vodnÃ­ch sekvencÃ­ spolu s doplnÄ›nÃ½mi mezerami Å™Ã­kÃ¡me <strong>alignment</strong>. NapÅ™Ã­klad pro <mathjax>\(n = 2\)</mathjax> bychom mohli dostat vstup</p><div class="highlight"><table class="sourcetable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="source"><pre><span></span>VLSEGKTEAPV
VLSPAPV
</pre></div></td></tr></tbody></table></div><p>ze kterÃ©ho bychom posklÃ¡dali napÅ™Ã­klad nÃ¡sledujÃ­cÃ­ alignment</p><div class="highlight"><table class="sourcetable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="source"><pre><span></span>VLSEGKTEAPV
VLS--P--APV
</pre></div></td></tr></tbody></table></div><p>V kÃ³du by tedy klidnÄ› mohl alignment vypadat nÄ›jak takto (i kdyÅ¾ v reÃ¡lu jej implementuji trochu jinak)</p><div class="highlight"><table class="sourcetable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="source"><pre><span></span><span class="kr">data</span> <span class="kt">Alignment</span> <span class="ow">=</span> <span class="kt">Alignment</span>
    <span class="p">{</span> <span class="n">aProteins</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Protein</span><span class="p">]</span>
    <span class="p">,</span> <span class="n">aProteinGaps</span> <span class="ow">::</span> <span class="p">[[</span><span class="kt">Gap</span><span class="p">]]</span>
    <span class="p">}</span>
</pre></div></td></tr></tbody></table></div><p>AlignmentÅ¯ existuje (nekoneÄnÄ›) mnoho, byly proto zavedeny zpÅ¯soby, jakÃ½mi je moÅ¾nÃ© odliÅ¡it dobrÃ© alignmenty od tÄ›ch Å¡patnÃ½ch. NejÄastÄ›jÅ¡Ã­ metodou je skÃ³rovÃ¡nÃ­ pomocÃ­ <strong>skÃ³rovacÃ­ch tabulek</strong> (scoring matrices), napÅ™Ã­klad BLOSUM 62 nebo PAM 250, kterÃ© vychÃ¡zejÃ­ z experimentÃ¡lnÃ­ch pozorovÃ¡nÃ­ proteinÅ¯. SkÃ³rovacÃ­ tabulky obsahujÃ­ skÃ³re pro vÅ¡echny moÅ¾nÃ© kombinace pÃ­smen (aminokyselin, AK), je tedy moÅ¾nÃ© alignment jednoduÅ¡e projet sloupec po sloupci, v danÃ©m sloupci oskÃ³rovat vÅ¡echny dvojice znakÅ¯ a vÃ½sledky seÄÃ­st.</p><h3 id="Tvorba generacÃ­"><a class="internal-link" href="#Tvorba generacÃ­">Tvorba generacÃ­</a></h3><p>Program na vstupu oÄekÃ¡vÃ¡ cestu k souboru, ve kterÃ©m bude na kaÅ¾dÃ©m Å™Ã¡dku sekvence AK a pomlÄek, kterÃ© budou pÅ™edstavovat mezeryâ€”to bude poÄÃ¡teÄnÃ­ (seed) alignment. Z nÄ›j je potÃ© vygenerovÃ¡na ÃºvodnÃ­ populace, kterÃ¡ ÄÃ­tÃ¡ 100 jedincÅ¯; tento poÄet je moÅ¾nÃ© zmÄ›nit, i kdyÅ¾ zatÃ­m ne zrovna uÅ¾ivatelsky pÅ™Ã­vÄ›tivÄ›.</p><p>KaÅ¾dÃ¡ dalÅ¡Ã­ generace je z tÃ© souÄasnÃ© vytvoÅ™ena nÃ¡sledujÃ­cÃ­m zpÅ¯sobem:</p><ol><li><mathjax>\(n\)</mathjax> nejlepÅ¡Ã­ch jedincÅ¯ je pÅ™eneseno do dalÅ¡Ã­ generace beze zmÄ›ny</li><li>je poÅ™Ã¡dÃ¡no <mathjax>\(t\)</mathjax> turnajÅ¯, kaÅ¾dÃ©ho z nich se ÃºÄastnÃ­ <mathjax>\(u\)</mathjax> nÃ¡hodnÄ› vybranÃ½ch jedincÅ¯
<ul><li>nejlepÅ¡Ã­ ze vÅ¡ech ÃºÄastnÃ­kÅ¯ se posouvÃ¡ do dalÅ¡Ã­ generace a je upraven pouze mutacÃ­</li><li>zbylÃ­ ÃºÄastnÃ­ci turnaje jsou rekombinovÃ¡ni s vÃ½hercem a potÃ© jeÅ¡tÄ› mutovÃ¡ni</li></ul></li></ol><p>Velikost kaÅ¾dÃ© generace je tedy dÃ¡na</p><div class="scrollable"><mathjax>\[v_{gen} = n + t \cdot u\]</mathjax></div><p>VÃ½chozÃ­ hodnoty jsou <mathjax>\(n = 1\)</mathjax>, <mathjax>\(t = 33\)</mathjax>, <mathjax>\(u = 3\)</mathjax> a tedy <mathjax>\(v_{gen} = 100\)</mathjax>, ale dajÃ­ se relativnÄ› snadno zmÄ›nit.</p><h3 id="RekombinaÄnÃ­ operace"><a class="internal-link" href="#RekombinaÄnÃ­ operace">RekombinaÄnÃ­ operace</a></h3><p>PouÅ¾Ã­vÃ¡m dva druhy rekombinaÄnÃ­ch operacÃ­: <strong>mutace</strong> a <strong>crossovery</strong>. Oba druhy se zabÃ½vajÃ­ pouze zmÄ›nou rozmÃ­stÄ›nÃ­, poÄtu a velikosti mezer v alignmentu, pÅ¯vodnÃ­ sekvence AK zÅ¯stÃ¡vajÃ­ nezmÄ›nÄ›ny. Proteiny proto reprezentuji jako</p><div class="highlight"><table class="sourcetable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="source"><pre><span></span><span class="kr">data</span> <span class="kt">Protein</span> <span class="ow">=</span> <span class="kt">Protein</span>
    <span class="p">{</span> <span class="n">pSeq</span> <span class="ow">::</span> <span class="kt">Vector</span> <span class="kt">Char</span>
    <span class="p">,</span> <span class="n">pGaps</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Gap</span><span class="p">]</span>
    <span class="p">}</span>
</pre></div></td></tr></tbody></table></div><p>protoÅ¾e sekvence jsou konstatnÃ­, zatÃ­mco mezery se neustÃ¡le mÄ›nÃ­.</p><div class="list"><list-title>Mutace</list-title><ul><li>mutujeme jedince, tedy alignment, ale mutace samotnÃ© se tÃ½kajÃ­ pouze jednoho proteinu z celÃ©ho alignmentu</li><li>v rÃ¡mci mutace pÅ™i tvoÅ™enÃ­ novÃ© generace mÅ¯Å¾e bÃ½t jeden alignment zmutovÃ¡n i nÄ›kolikrÃ¡t za sebou</li><li>rozliÅ¡uji pÄ›t druhÅ¯ mutacÃ­
<ol><li><code>insert</code> vloÅ¾Ã­ do nÃ¡hodnÃ©ho proteinu na nÃ¡hodnÃ© mÃ­sto mezeru, jejÃ­Å¾ velikost je nÃ¡hodnÃ¡, ale odvÃ­jÃ­ se od prÅ¯mÄ›rnÃ© velikosti mezer v seed alignmentu</li><li><code>increase</code> zvÄ›tÅ¡Ã­ v nÃ¡hodnÃ©m proteinu nÃ¡hodnou mezeru o nÃ¡hodnou velikost</li><li><code>descease</code> ditto, ale zmenÅ¡Ã­, a vÅ¾dy pouze o 1</li><li><code>delete</code> zkusÃ­ v nÃ¡hodnÃ©m proteinu vymazat nÃ¡hodnou mezeru, Å¡ance ÃºspÄ›chu se sniÅ¾uje s dÃ©lkou mezery</li><li><code>shift</code> pÅ™esune v nÃ¡hodnÃ©m proteinu nÃ¡hodnou mezeru na jinÃ© mÃ­sto, pÅ™Ã­padnÄ› je-li toto mÃ­sto jiÅ¾ nÄ›jakou mezerou obsazeno, prohodÃ­ velikosti tÄ›chto dvou mezer</li></ol></li><li>jednotlivÃ© druhy mutace (â€œmutaÄnÃ­ operaceâ€) jsou aplikovÃ¡ny s rÅ¯znou pravdÄ›podobnostÃ­; tyto pravdÄ›podobnosti se navÃ­c v prÅ¯bÄ›hu programu pÅ™izpÅ¯sobujÃ­ tomu, jak je kterÃ½ druh mutace ÃºspÄ›Å¡nÃ½
<ul><li>mechanismus je v detailu popsanÃ½ v druhÃ©m paperu, v podstatÄ› se ale jednÃ¡ o to, Å¾e dÃ¡vÃ¡me do souvislosti skÃ³re pÅ™ed mutacÃ­ a po nÃ­ s poÄtem aplikacÃ­ konkrÃ©tnÃ­ mutaÄnÃ­ operace</li></ul></li></ul></div><box class="plain"><div class="title">PoznÃ¡mka</div><div class="body">Rozhodl jsem se nakonec upustit od dynamickÃ©ho pÅ™izpÅ¯sobovÃ¡nÃ­ pravdÄ›podobnostÃ­, mÃ­sto toho jsem pro insert, increase, decrease, delete a shift zavedl fixnÃ­ pravdÄ›podobnosti 0.5, 0.2, 0.1, 0.1, 0.1 (respektive). VÃ­ce informacÃ­ v sekci <a href="#OsobnÃ­ poznÃ¡mky">osobnÃ­ poznÃ¡mky</a>.</div></box><div class="list"><list-title>Crossovery</list-title><ul><li>jsou pouÅ¾Ã­vÃ¡ny pro alignmenty, kterÃ© prohrajÃ­ turnaj</li><li>rozliÅ¡uji dva druhy crossoverÅ¯
<ol><li>horizontÃ¡lnÃ­: z rodiÄovskÃ½ch alignmentÅ¯ vznikne potomek tak, Å¾e pro kaÅ¾dÃ½ protein zÃ­skÃ¡ vÅ¡echny mezery nÃ¡hodnÄ› z jednoho, nebo druhÃ©ho rodiÄe
    <pre>RodiÄe:
<strong>VLSEGKTEAPV</strong>     VLSEGKTEAPV
<strong>VLS--P--APV</strong>  +  --VLSP--APV
<strong>-EGKT---A--</strong>     ---EGKTA---

Potomek:
<strong>VLSEGKTEAPV</strong>
--VLSP--APV
<strong>-EGKT---A--</strong></pre></li><li>vertikÃ¡lnÃ­: z rodiÄovskÃ½ch alignmentÅ¯ vznikne potomek tak, Å¾e pro kaÅ¾dÃ½ protein vÅ¡echny mezery pÅ™ed <mathjax>\(k\)</mathjax>-tou AK pÅ™evezme od jednoho z rodiÄÅ¯ a mezery po <mathjax>\(k\)</mathjax>-tÃ© AK pÅ™evezme od druhÃ©ho
    <pre>RodiÄe:
<strong>VLSEGKTEAPV</strong>     VLSEGKTEAPV
<strong>VLS--P--APV</strong>  +  --VLSP--APV
<strong>-EGKT---A--</strong>     ---EGKTA---

Protomek (k = 3):
<strong>VLS</strong>EGKTEAPV
<strong>VLS</strong>P--APV
<strong>-EGK</strong>TA---</pre></li></ol></li></ul></div><p>Je vidÄ›t, Å¾e pÅ™i vertikÃ¡lnÃ­m crossoveru se nÄ›kdy pokazÃ­ â€œblokovitostâ€ celÃ©ho alignmentu. V takovÃ©m pÅ™Ã­padÄ› jsou doplnÄ›ny mezery na konec vÅ¡ech kratÅ¡Ã­ch proteinÅ¯.</p><h3 id="Fitness function"><a class="internal-link" href="#Fitness function">Fitness function</a></h3><p>Jako fitness funkce mi poslouÅ¾il bÄ›Å¾nÃ½ pairwise sequence alignment: v rÃ¡mci alignmentu spolu podle skÃ³rovacÃ­ tabulky srovnÃ¡m vÅ¡echny dvojice proteinÅ¯ a seÄtu jejich skÃ³re. PouÅ¾Ã­vÃ¡m tabulku <a href="https://en.wikipedia.org/wiki/BLOSUM">BLOSUM62</a>, kterÃ¡ se pro alignmenty proteinÅ¯ pouÅ¾Ã­vÃ¡ bÄ›Å¾nÄ›.</p><p>SamozÅ™ejmÄ› se hodnotÃ­ i mezery; protoÅ¾e mezery v pÅ™Ã­rodÄ› nevznikajÃ­ pÅ™Ã­liÅ¡ Äasto, majÃ­ vÅ¾dy zÃ¡pornÃ© skÃ³re. NavÃ­c vznik mezery je mÃ©nÄ› pravdÄ›podobnÃ½ neÅ¾ rozÅ¡Ã­Å™enÃ­ nÄ›jakÃ© jiÅ¾ existujÃ­cÃ­, takÅ¾e â€œprvnÃ­ blokâ€ mezery mÃ­vÃ¡ menÅ¡Ã­ skÃ³re neÅ¾ vÅ¡echny ostatnÃ­ bloky (v rÃ¡mci jednÃ© kontinuÃ¡lnÃ­ mezery). PÅ™i poÄÃ­tÃ¡nÃ­ skÃ³re Ãºseku, kde jsou v obou hodnocenÃ½ch proteinech mezery, se danÃ½ Ãºsek pÅ™eskakuje. Mezery na konci proteinu se zpravdila napoÄÃ­tajÃ­, ale jÃ¡ je poÄÃ­tÃ¡m, protoÅ¾e jsem tak dostal lepÅ¡Ã­ vÃ½sledky.</p><h2 id="Orientace v kÃ³du"><a class="internal-link" href="#Orientace v kÃ³du">Orientace v kÃ³du</a></h2><p>KÃ³d je rozdÄ›len na nÄ›kolik modulÅ¯.</p><dl><dt>Model</dt><dd>Modul obsahujÃ­cÃ­ definice zÃ¡kladnÃ­ch datastruktur. Zde ti doporuÄuji zaÄÃ­t ÄÃ­st.</dd><dt>MultipleSeqAlignment</dt><dd>HlavnÃ­ modul celÃ©ho balÃ­Äku, kombinuje vÅ¡echny ostatnÃ­ moduly. Jsou zde tvoÅ™eny novÃ© generace a dajÃ­ se zde takÃ© zmÄ›nit zÃ¡kladnÃ­ vlastnosti celÃ©ho algoritmu, napÅ™. poÄet generacÃ­, velikost populace atd.</dd><dt>Crossover, Mutation, Scoring (+ ScoringMatrix), Utils</dt><dd>Moduly obsahujÃ­cÃ­ kÃ³d crossoveru, mutacÃ­, skÃ³rovacÃ­ funkce a pomocnÃ½ch funkcÃ­ (respektive). ZvlÃ¡Å¡tÄ› v mutation je (oproti zbytku balÃ­Äku) relativnÄ› zajÃ­mavÃ½ kÃ³d, kde pouÅ¾Ã­vÃ¡m monad transformery.</dd><dt>MutationProbabilities</dt><dd>Modul, kterÃ½ vlastnÄ› nenÃ­ pouÅ¾Ã­vÃ¡nâ€”slouÅ¾il k dynamickÃ©mu pÅ™izpÅ¯sobovÃ¡nÃ­ pravdÄ›podobnostÃ­ jednotlivÃ½ch typÅ¯ mutacÃ­. Na Å™Ã¡dku 63 lze odkomentovat kÃ³d, kterÃ½ tuto funkcionalitu opÄ›t zapne.</dd></dl><p>Funkce <code>main</code> (a potaÅ¾mo <code>stack exec</code>) ÄekÃ¡ jeden argument: cestu k textovÃ©mu souboru, ve kterÃ©m bude na kaÅ¾dÃ©m Å™Ã¡dku jedna sekvence znakÅ¯ aminokyselin a pomlÄek. Soubor tedy mÅ¯Å¾e vypadat napÅ™Ã­klad nÃ¡sledovnÄ›:</p><div class="highlight"><table class="sourcetable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="source"><pre><span></span>---MAIGFVIVTFQEQGETEYKNCELDKNQRQCVQYA--LKAR----------P-------LRCY---IPKNPYQYQVWYVVTSSYF------------
-------------------S------KMTEEECRGYYYVYKDGDPT-----Q--------------MELRPRQ-----W---IHNDFHFDNVLSAMMS-
-----------------------------------ISMGLESS-TISVVKILRVLRLLQFMFACIGVQLFKGK------------FFSCNDL-------
FTNFILLFILLSSAALAAED------PIRAESVRNQILGYFDIAFTSVFTVEIVLK-----MTTYGAFLHKGS-----F---CRNYFNILDLLVVAVSL
------------------------------------------------------------------------------------EYLMFIDVILS----
</pre></div></td></tr></tbody></table></div><p>ObecnÄ› je lepÅ¡Ã­ na vstupu dÃ¡vat uÅ¾ naalignovanÃ© sekvence, kterÃ© potÃ© algorimus uÅ¾ jen vylepÅ¡Ã­. HledÃ¡nÃ­ alignmentÅ¯ ÃºplnÄ› od pÃ­ky mu moc nejde (coÅ¾ je obecnÃ¡ vlastnost vÅ¡ech genetickÃ½ch MSA).</p><h2 id="OsobnÃ­ poznÃ¡mky"><a class="internal-link" href="#OsobnÃ­ poznÃ¡mky">OsobnÃ­ poznÃ¡mky</a></h2><p>Do tohoto projektu jsem Å¡el s naprostou neznalostÃ­ genetickÃ½ch algoritmÅ¯, jen jsem o nich pÅ™edtÃ­m pÃ¡rkrÃ¡t nÄ›kde Äetl. UÅ¾ pÃ¡r let si vÅ¡ak hÃ½ÄkÃ¡m pÅ™edstavu, Å¾e nÄ›kdy nÄ›jakÃ½ napÃ­Å¡u; myÅ¡lenka, kterÃ¡ za nimi stojÃ­, mi vÅ¾dycky pÅ™iÅ¡la geniÃ¡lnÃ­. Nechat pÅ™Ã­rodu a nÃ¡hodu udÄ›lat tÄ›Å¾kou prÃ¡ci za nÃ¡s... BoÅ¾Ã­!</p><p>UkÃ¡zalo se, Å¾e aÅ¾ tak idylickÃ© to s nimi nenÃ­. ÄŒlovÄ›k mÃ¡ k dispozici velkou spoustu rÅ¯znÃ½ch ÄudlÃ­kÅ¯, pÃ¡Äek a vypÃ­naÄÅ¯, vÅ¡echny bez popisnÃ½ch cedulek, z nichÅ¾ nÄ›kterÃ© vypÃ­naÄe ani nejsou zapojeny, a nÄ›kterÃ© sice jsou, ale pouze zapÃ­najÃ­ a vypÃ­najÃ­ jinÃ© vypÃ­naÄe atd. NÄ›kdy je to aÅ¾ k zblÃ¡znÄ›nÃ­.</p><p>Proto jsem byl nakonec nucen odstoupit od postupu, kterÃ½ byl prosazovÃ¡n v druhÃ©m ÄlÃ¡nku, totiÅ¾ od dynamickÃ© Ãºpravy pravdÄ›podobnostÃ­ jednotlivÃ½ch mutacÃ­. Z jakÃ©hosi zÃ¡hadnÃ©ho dÅ¯vodu, kterÃ½ se mi nepodaÅ™ilo najÃ­t ani po nÄ›kolika probdÄ›lÃ½ch nocÃ­ch, neustÃ¡le roste pravdÄ›podobnost <code>insert</code> a to aÅ¾ do tÃ© mÃ­ry, Å¾e by pravdÄ›podobnosti ostatnÃ­ch funkcÃ­ klesly na 0. PÅ™esto vÅ¡ak vÃ½slednÃ½ alignment mnoho mezer nemÃ¡, spÃ­Å¡e naopak.</p><p>KdyÅ¾ se toto dynamickÃ© chovÃ¡nÃ­ vymÄ›nÃ­ za fixnÃ­, program se nÄ›kolikanÃ¡sobnÄ› zrychlÃ­ a je tedy moÅ¾nÃ© nechat bÄ›Å¾et Å™Ã¡dovÄ› vÃ­ce generacÃ­, coÅ¾ nakonec vede k lepÅ¡Ã­mu vÃ½sledku za stejnÃ½ Äas. S implementacÃ­ dynamickÃ½ch pravdÄ›podobnostÃ­ bylo vÅ¡ak tolik prÃ¡ce, Å¾e jsem se rozhodl tam veÅ¡kerÃ½ kÃ³d nechat (a jde zprovoznit odkomentovÃ¡nÃ­m Å™Ã¡dku 63 v modulu <code>Genetics.MutationProbabilities</code>). Snad se mi to nÄ›kdy jeÅ¡tÄ› podaÅ™Ã­ opravit.</p><p>Moc rÃ¡d bych takÃ© implementoval paralelnÃ­ bÄ›h kÃ³du; kdyÅ¾ jsem spustil profiler, vyÅ¡lo mi, Å¾e nejvÃ­ce Äasu se ztratÃ­ (dle oÄekÃ¡vÃ¡nÃ­) ve skÃ³rovacÃ­ funkci. Ta nijak neovlivÅˆuje ostatnÃ­ ÄÃ¡sti programu a navÃ­c se sklÃ¡dÃ¡ z mnoha nezÃ¡vislÃ½ch ÄÃ¡stÃ­, a tak se paralelizace pÅ™Ã­mo nabÃ­zÃ­.</p>
    </div>
     <page-end> â‹… ğ“” â‹… </page-end>
    </body>
</html>